1) When say Sorted Think of Two Pointers

2) When say return Linked List ( a new one ) use Sentinel Pattern

3) When asked to append to string or create a new resultant String go for StringBuilder beacuse, 
  String concatenation (str = str + s.charAt(i)) creates a new string every time ‚Üí O(n¬≤) time.
  StringBuilder modifies in-place ‚Üí O(n) time.

4) Duplicates ? Set or HashSet

5) When asked to find MAX_SUM in Circular Fashion, Remember, MAX_CIRCULAR_SUM (of some subarray) = TOTAL_SUM - MIN_SUM;  (Max Circular Subarray Sum)
   Two cases Sum can be MAX_SUM Kadane's MAXSUM Algo or MAX_CIRCULAR_SUM
   To handle all negative  if(MAX_SUM > 0) return MAX_CIRCULAR_SUM, else MAX_SUM;  

6) When asked to rotate a linked list (right rotation) or (left rotation) the last node of rotated list from left will be at len - k position 1 based indexing

7) Longest Repeating Character concept 
  currWinLen - maxF <= k

  otherwise shrink window, HashMap, or Hash-Array needed

8) An Array is Faster than a HashMap, so where you think of HashMap, try converting to array

9) for sums that are affected by carry as 0/1 sum = x + y + carry.

10) When asked to find subarray sum k remember
    if prefix sum is x and there exists a (prefix_sum - k) sum , then the remaining is k sum, okay use HashMap

11) When asked to return an element of pascal triangle at any row and col, the formula is (row - 1 C col - 1)
    nCr = n! / (r! * (n-r)!)  go, till r positions only for optimization

12) when asked to return row based on zero-based indexing of columns do 
    ans = ans * (row - col)
    ans = ans / col

13) When asked to check if a number is a power of 2 do
    (n > 0) && ((n & (n - 1)) == 0 if true it is

    8 & 7 ‚Üí 1000 & 0111 = 0000  ‚úÖ
    4 & 3 ‚Üí 0100 & 0011 = 0000  ‚úÖ
    6 & 5 ‚Üí 0110 & 0101 = 0100 ‚â† 0 ‚ùå  (not power of two)

14) When need to check if any character is AlphaNumeric [^a-zA-Z0-9], use Character.isLetterOrDigit(s.charAt(i))

15) Roman to Integer Conversion (IMP)
    Given a string s representing a Roman numeral, find it's corresponding integer value.
    Roman numerals are formed using the following symbols: I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, and M = 1000.
    Numbers are typically formed by combining these symbols from left to right, adding or subtracting their values based on specific rules.

    How does the conversion work?

    If a smaller value symbol comes before, we subtract. Otherwise, we add.
    In IV, I comes before V and V has a larger value 5. So our result is 5 - 1 = 4.
    In VI, V comes before I and I has a smaller value 1. So our result is 5 + 1 = 6.
    In II, we have same values, so we add and get 1 + 1 = 2
    In case of more than 2 characters, we traverse from left to right and group only when we see a greater value character after a smaller value character. 
    For example MXVII is 1000 + 10 + 5 + 1 + 1 = 1017. And XLVII is (50 - 10) + 5 + 1 + 1 = 47. Note that L is larger and comes after X.

16) When asked to split a string use:- split function
    String[] parts = s.split(":"); here : is the delimiter or spliter

17) When needed to see if the ith Bit of a binary conversion of (n) is set (1) or not use
    if((n & (1 << i)) != 0)
        if this condn is TRUE means BIT IS SET/ 1

    for integers run loop from 0 to 32 as, integer's size is 32 bits, 0 - 31

18) When asked to convert a num to char array , use: 
    char[] arr = String.valueOf(num).toCharArray();

19) LPS Prefix-Suffix Algorithmm (https://youtu.be/sODA1BzFvsE?si=WGyw4utPrCS7ajE1)
    Goal: Find the longest prefix of a string which is also a suffix.
    
    Algorithm :- 
    1) Start
    
        a] Let lps be an array to store the lengths.
        
        b] prefix = 0 (length of matched prefix)
        
        c] suffix = 1 (current character index we are checking)
        
    2) While suffix is in range:
    
        a]  If characters match ‚Üí
            prefix++, set lps[suffix] = prefix, move suffix++
        
        b] If characters don't match ‚Üí
        
              i] If prefix > 0 ‚Üí jump back: prefix = lps[prefix - 1]
    
              ii] Else ‚Üí lps[suffix] = 0, move suffix++
    
    3) End ‚Üí lps[n-1] is your answer.
    
    Why This is O(n) and not O(n¬≤)
    You never re-check characters unnecessarily.
    
    On mismatch, instead of starting from scratch, you reuse previous lps values to skip checks.
    
    üí° Memory Trick
    Just say to yourself:
    
    "When match ‚Üí grow both prefix & suffix.
    When mismatch ‚Üí shrink prefix, keep suffix."

20) KMP Search Algorithm (Needle in Haystack)
    Variables:
    
    first ‚Üí pointer in haystack
    
    second ‚Üí pointer in needle
    
    lps[] ‚Üí longest prefix-suffix array for needle
    
    Algorithm
    1)Preprocess:
      Build lps[] for the needle using the LPS algorithm.
    
    2) Search:
      While first < haystack.length && second < needle.length:
    
          a] If characters match:
                Move both first and second forward.
    
          b] If mismatch & second > 0:
                Move second back to lps[second - 1].
    
          c] If mismatch & second == 0:
                Move first forward.
    
          d] Match found:
              If second == needle.length, return first - second (start index).

      loop ends

      e] No match:
          Return -1.
    
    1-line mnemonic
    "Match = go forward, mismatch = jump using LPS, never rewind haystack."

21) s.substring(i, j+1) returns the substring of a string from i - j

22) s1.compareTo(s2) returns int value based on comparing strings lexicographically

23) (1 << i) creates a binary number

24) Comparators, Lamba Expressions need to make Integer[] temp = new Integer[n]; as Comparator works on Integer Objects and not Primitive data-types

25) If there is an array of length (n), then no. of subarrays of that array are [ (n * (n + 1)) / 2 ]

26) To run a Java WhiteBoard file, Go to that file's location then if FileName is Hello.java and Class Name is also Hello then

    javac Hello.java -> compiles
    java Hello       -> runs

27) For a matrix of size (m x n) there are m + n - 1 diagonals

28) Arraylist addAll -> this will add all the elements of list 2 in list 1,
    if you want index specific like l1.addAll(index, l2);

29) for Integer to int 
    use Integer.intValue()

30) When asked to iterate over a HashMap
    use: 
    for (Map.Entry<Integer,Integer> ele : map.entrySet()) map is the name of HashMap
    for keys: ele.getKey(), for values: ele.getValue()

31) When asked to fill an ArrayList use:

  ArrayList<Integer> res = new ArrayList<>(Collections.nCopies(n, -1));

32) for arrays use Arrays.fill(arr, -1);

33) if we don't want to use ceil for division thing then

    ceil of (a / b) is (a + b - 1 / b) always works 
