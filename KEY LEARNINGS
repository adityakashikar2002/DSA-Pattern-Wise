1) When say Sorted Think of Two Pointers

2) When say return Linked List ( a new one ) use Sentinel Pattern

3) When asked to append to string or create a new resultant String go for StringBuilder beacuse, 
  String concatenation (str = str + s.charAt(i)) creates a new string every time ‚Üí O(n¬≤) time.
  StringBuilder modifies in-place ‚Üí O(n) time.

4) Duplicates ? Set or HashSet

5) When asked to find MAX_SUM in Circular Fashion, Remember, MAX_CIRCULAR_SUM (of some subarray) = TOTAL_SUM - MIN_SUM;  (Max Circular Subarray Sum)
   Two cases Sum can be MAX_SUM Kadane's MAXSUM Algo or MAX_CIRCULAR_SUM
   To handle all negative  if(MAX_SUM > 0) return MAX_CIRCULAR_SUM, else MAX_SUM;  

6) When asked to rotate a linked list the last node from left will be at len - k position 1 based indexing

7) Longest Repeating Character concept 
  currWinLen - maxF <= k

  otherwise shrink window, HashMap, or Hash-Array needed

8) An Array is Faster than a HashMap, so where you think of HashMap, try converting to array

9) for sums that are affected by carry as 0/1 sum = x + y + carry.

10) When asked to find subarray sum k remember
    if prefix sum is x and there exists a (prefix_sum - k) sum , then the remaining is k sum, okay use HashMap

11) When asked to return an element of pascal triangle at any row and col, the formula is (row - 1 C col - 1)
    nCr = n! / (r! * (n-r)!)  go, till r positions only for optimization

12) when asked to return row based on zero-based indexing of columns do 
    ans = ans * (row - col)
    ans = ans / col

13) When asked to check if a number is a power of 2 do
    (n > 0) && ((n & (n - 1)) == 0 if true it is

    8 & 7 ‚Üí 1000 & 0111 = 0000  ‚úÖ
    4 & 3 ‚Üí 0100 & 0011 = 0000  ‚úÖ
    6 & 5 ‚Üí 0110 & 0101 = 0100 ‚â† 0 ‚ùå  (not power of two)

13) When need to check if any character is AlphaNumeric [^a-zA-Z0-9], use Character.isLetterOrDigit(s.charAt(i))

14) Roman to Integer Conversion (IMP)
    Given a string s representing a Roman numeral, find it's corresponding integer value.
    Roman numerals are formed using the following symbols: I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, and M = 1000.
    Numbers are typically formed by combining these symbols from left to right, adding or subtracting their values based on specific rules.

    How does the conversion work?

    If a smaller value symbol comes before, we subtract. Otherwise, we add.
    In IV, I comes before V and V has a larger value 5. So our result is 5 - 1 = 4.
    In VI, V comes before I and I has a smaller value 1. So our result is 5 + 1 = 6.
    In II, we have same values, so we add and get 1 + 1 = 2
    In case of more than 2 characters, we traverse from left to right and group only when we see a greater value character after a smaller value character. 
    For example MXVII is 1000 + 10 + 5 + 1 + 1 = 1017. And XLVII is (50 - 10) + 5 + 1 + 1 = 47. Note that L is larger and comes after X.

15) When asked to split a string use:- split function
    String[] parts = s.split(":"); here : is the delimiter or spliter

16) When needed to see if the ith Bit of a binary conversion of (n) is set (1) or not use
    if((n & (1 << i)) != 0)
        if this condn is TRUE means BIT IS SET/ 1

    for integers run loop from 0 to 32 as, integer's size is 32 bits, 0 - 31

17) When asked to convert a num to char array , use: 
    char[] arr = String.valueOf(num).toCharArray();

18) LPS Prefix-Suffix Algorithmm (https://youtu.be/sODA1BzFvsE?si=WGyw4utPrCS7ajE1)
    Goal: Find the longest prefix of a string which is also a suffix.
    
    Algorithm (in your terms)
    1) Start
    
        a] Let lps be an array to store the lengths.
        
        b] prefix = 0 (length of matched prefix)
        
        c] suffix = 1 (current character index we are checking)
        
    2) While suffix is in range:
    
        a]  If characters match ‚Üí
            prefix++, set lps[suffix] = prefix, move suffix++
        
        b] If characters don't match ‚Üí
        
              i] If prefix > 0 ‚Üí jump back: prefix = lps[prefix - 1]
    
              ii] Else ‚Üí lps[suffix] = 0, move suffix++
    
    3) End ‚Üí lps[n-1] is your answer.
    
    Why This is O(n) and not O(n¬≤)
    You never re-check characters unnecessarily.
    
    On mismatch, instead of starting from scratch, you reuse previous lps values to skip checks.
    
    üí° Memory Trick
    Just say to yourself:
    
    "When match ‚Üí grow both prefix & suffix.
    When mismatch ‚Üí shrink prefix, keep suffix."

19) KMP Search Algorithm (Needle in Haystack)
    Variables:
    
    first ‚Üí pointer in haystack
    
    second ‚Üí pointer in needle
    
    lps[] ‚Üí longest prefix-suffix array for needle
    
    Algorithm
    1)Preprocess:
      Build lps[] for the needle using the LPS algorithm.
    
    2) Search:
      While first < haystack.length && second < needle.length:
    
          a] If characters match:
                Move both first and second forward.
    
          b] If mismatch & second > 0:
                Move second back to lps[second - 1].
    
          c] If mismatch & second == 0:
                Move first forward.
    
          d] Match found:
              If second == needle.length, return first - second (start index).

      loop ends

      e] No match:
          Return -1.
    
    1-line mnemonic
    "Match = go forward, mismatch = jump using LPS, never rewind haystack."

20) Longest Periodic Proper Prefix
    Goal: Find the longest periodic proper prefix of a string ‚Äî the largest starting chunk that can be repeated to match the start of the original string.

    Idea:
    
    If a string has repeated patterns, its prefix will match a suffix somewhere.
    
    That‚Äôs where LPS (from KMP) comes in: it tells us the longest prefix that is also a suffix, i.e., the repeated pattern.
    
    Finding the period:
    
    Let len = lps[n-1] ‚Üí length of the longest border (prefix = suffix).
    
    Shift = n - len ‚Üí the size of the repeating block.
    
    This shift is the point where the overlap happens if you ‚Äúslide‚Äù the string over itself.
    
    Check if it repeats perfectly:
    
    If n % (n - len) == 0 ‚Üí the block repeats fully across the string.
    
    Then the longest periodic proper prefix length = n - (n - len) (or just len).
    
    Otherwise:
    
    No valid periodic proper prefix ‚Üí return -1.
    
    üí° Analogy:
    
    The string is a LEGO train.
    
    LPS finds the front piece that also appears at the back.
    
    n - len tells you how long the repeating LEGO block is.
    
    Dividing n % (n - len) checks if the train can be built by stacking this block exactly, without any leftover piece.
    
    the LPS tells us the pattern, (n - len) tells us the repeating block, and the modulus check ensures it repeats perfectly to form the original string. ‚úÖ
