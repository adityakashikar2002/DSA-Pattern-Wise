// Brute Approach: Time:- O(m x n)
---------------------------------------------------------------------------------------------------------------------
// Better Approach 
// Time: O(m + log n)
// Space: O(1)
---------------------------------------------------------------------------------------------------------------------
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;

        for(int i = 0; i < m; i++)
        {
            if(target >= matrix[i][0] && target <= matrix[i][n - 1]) // find where the target fits in range of matrix
            {
                int low = 0;
                int high = n - 1;
                // apply binary search on that row of matrix as its sorted
                while(low <= high)
                {
                    int mid = (low + high) / 2;

                    if(matrix[i][mid] == target)
                        return true;
                    
                    if(target < matrix[i][mid])
                    {
                        high = mid - 1;
                    }
                    else
                    {
                        low = mid + 1;
                    }
                }
            }
        }

        return false;
    }
}
---------------------------------------------------------------------------------------------------------------------
// Optimal Approach 
// Time: O(log(m x n))
// Space: O(1)
---------------------------------------------------------------------------------------------------------------------

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;

        // poora matrix sorted hai to usko ek 1D - Array samaj k chalo
        // aisa kiya to 1D array k index ko 2D k indexes me badalna padega
        // to agar koi index hai (i) 1D array ki, 
        // to row hoga i / cols
        // aur col hoga i % cols

        // aisa  isliye kyuki 
        // 1  3  5  7 
        // 10 11 16 20
        // 23 30 34 60 

        // iske index 1D array me visualize kiye to
        // 0 1 2  3
        // 4 5 6  7
        // 8 9 10 11

        // agar index 5 hoga to matrix me uska row 5 / no. of cols 5 / 4 = 1 hoga 
        // yee isliye kyuki row k liye already ek baar cols,

        // Each row has m elements.

        // The row number is: how many full rows fit before this index → i / n.
        // The column number is: what’s left over after filling full rows → i % n.

        // i/ n strips away how many full rows are before this point.

        // i % n tells you the leftover position inside the current row.

        int low = 0;
        int high = (m * n) - 1;

        while(low <= high)
        {
            int mid = (low + high) / 2;

            int r = mid / n;
            int c = mid % n;

            if(matrix[r][c] == target)
                return true;
            
            if(target < matrix[r][c])
                high = mid - 1;
            else
                low = mid + 1;
        }

        return false;
    }
}
