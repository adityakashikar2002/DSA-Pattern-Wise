// Brute Force Approach
// Time: O(n)
// Space: O(1)
---------------------------------------------------------------------------------------------------
class GFG {
    ArrayList<Integer> find(int arr[], int x) {
        // code here
        
        int n = arr.length;
        
        int first = - 1;
        int last = -1;
        
        ArrayList<Integer> res = new ArrayList<>();
        
        for(int i = 0; i < n; i++)
        {
            if(arr[i] == x)
            {
                if(first == -1)
                {
                    first = i;
                    last = i;
                }
                else
                {
                    last = i;
                }
            }
        }
        
        res.add(first);
        res.add(last);
        
        return res;
    }
}
---------------------------------------------------------------------------------------------------

// Optimal Approach
// Time: O(logn + logn) ~ O(logn)
// Space: O(1)
---------------------------------------------------------------------------------------------------
class GFG {
    
    int binarySearchFirst(int[] arr, int target)
    {
        int n = arr.length;
        
        int first = -1;
        
        int low = 0;
        int high = n - 1;
        
        while(low <= high)
        {
            int mid = (low + high) / 2;
            
            if(arr[mid] == target)
            {
                first = mid;
                high = mid - 1; // keep searching left
            }
            else if(arr[mid] > target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        
        return first;
    }
    
    int binarySearchLast(int[] arr, int target)
    {
        int n = arr.length;
        
        int last = -1;
        
        int low = 0;
        int high = n - 1;
        
        while(low <= high)
        {
            int mid = (low + high) / 2;
            
            if(arr[mid] == target)
            {
                last = mid;
                low = mid + 1; // keep searching right
            }
            else if(arr[mid] > target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        
        return last;
    }
    
    ArrayList<Integer> find(int arr[], int x) {
        // code here
        
        int n = arr.length;
        
        int first = - 1;
        int last = -1;
        
        ArrayList<Integer> res = new ArrayList<>();
        
        first = binarySearchFirst(arr, x); // searches 1st occurence
        last = binarySearchLast(arr, x);   // searches last occurence
        
        res.add(first);
        res.add(last);
        
        return res;
    }
}
