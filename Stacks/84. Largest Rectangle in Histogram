// Brute Force
// Time: O(7n) - if we consider stack pop, push, update for each ele ~ otherwise O(3n), NSE, PSE, linear traversal
// Space: O(4n)
--------------------------------------------------------------------------------------------------------------------------
Even though the Time and Space Complexity reduces to O(n) the solution is still slower 
--------------------------------------------------------------------------------------------------------------------------

/** 
    agar area nikalne ki baat kre to kuch aise nikal skhte hai
    ek-ek element (bar) ko pakdo aur dekho uska kaha tak aage yaa peeche tak kheech shte hai i mean uski height 
    valid rahti

    heights = [2 1 5 6 2 3]

    iss example me 2 ko dekhenge to max index 1 tak jaega keuki 1 vali index par 1 hai (1 < 2)
    max height 2 invalid ho jaegi, aur peeche to kuch hai hi nhi so maxArea 2 hoga

    abhi 4th index vale 2 ko dekho
    kaha tak kheech skhte right me ??
    end tak le skhte kyuki 2 k aage k sare elements usse bade hai (3 > 2)
    aur peeche left me kaha tak kheech skhte to index no. 1 tak jaha 1 hai vaha tak kheech skhte (1 < 2)
    in dono indexes right vali aur left vali k beech me apn ko maxArea milega
    like 2 k liye jo bhi NSE(Next Smaller Element) hoga vo index - PSE(Previous Smaller Element) iska index apne
    rectangle ki length banega

    lekin 2 ka NSE to -1 hai kyuki 2 se chota to right me koi hai hi nhi to iss case me arr.length jo last index apn
    hypothetical n - size of array le lenge

    so area of rectangle hoga 2 x (NSE(6) - PSE(1) - 1) = 2 x (6 - 1 - 1) = 2 x 4 = 8 area hoga

    akhir me -1 isliye kyuki apn ko NSE aur PSE k beech ka area chaiye so..

    to yee har ek liye krna padega

    to sabse easy tarika hoga ki aap
    array k sare elements k PSE aur NSE nikal k rakho, bss NSE k liye jaha -1 vaha n krna, PSE me garaj nhi

    formula me put kro answer nikalo bss. aur maxArea to ata hi hai ðŸ˜…

    Formula:
        area = height x [NSE[height] - PSE[height] - 1]

*/
class Solution {

    public int[] nextSmallerElement(int[] arr)
    {
        int n = arr.length;
        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for(int i = 0; i < n; i++)
        {
            while(!st.isEmpty() && arr[st.peek()] > arr[i])
            {
                int top = st.pop();
                ans[top] = i;
            }

            st.push(i);
        }

        while(!st.isEmpty())
        {
            ans[st.pop()] = n;
        }

        return ans;
    } 

    public int[] previousSmallerElement(int[] arr)
    {
        int n = arr.length;
        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for(int i = 0; i < n; i++)
        {
            while(!st.isEmpty() && arr[st.peek()] >= arr[i])
            {
                st.pop();
            }

            if(st.isEmpty())
            {
                ans[i] = -1;
                st.push(i);
            }
            else
            {
                ans[i] = st.peek();
                st.push(i);
            }
        }

        return ans;
    } 

    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] NSE = nextSmallerElement(heights);
        int[] PSE = previousSmallerElement(heights);

        int maxArea = 0;

        for(int i = 0; i < n; i++)
        {
            int area = heights[i] * (NSE[i] - PSE[i] - 1);

            maxArea = Math.max(maxArea, area);
        }

        return maxArea;
    }
}
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
// Optimal Approach
// Time: O(n)
// Space: O(n)
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------

/*
    so... sabse optimal tarika kya hoga ?? taki hum space aur runtime kam kr skhe
    kya aisa nhi ho skhta ki hum ek traversal me hi NSE aur PSE nikal le ??

    like ho skhta, hum apna khandani code PSE k hisab se lihenge Stack vala okay
    ab jab bhi peek > curr hoga matlab, curr peek ka NSE ban gaya bss khatam baat
    jab bhi pop krne vale honge, to pop se pahle hi hame NSE mil jaega aur pop k baad jo stack me peek rahega vo 
    pop hue ele ka PSE hoga simple
    ek dry run dekhte hai

    heights = [2, 1, 5, 6, 2, 3]
    indexes = [0, 1, 2, 3, 4, 5]

    Step 1:
    sabse pahle stack me 2 (index - 0) gaya
    ab 1 pe point kr raha, 1 < 2
    matlab 1 , 2 ka NSE hai
    abhi 2 ko pop krenge, kr diya stack empty ho gaya matlab 2 ka koi PSE nhi tha so -1

    Step 2:
    stack k top pr 1 hai (index - 1), pointer (index - 2) 5 pr hai
    5 > 1 so push krenge bss

    Step 3:
    ab top pr 5 hai 6 ko push kiya

    Step 4:
    ab stack k top pr 6 hai (index - 3), i ab 2 pr hai (index - 4)
    so ab 2 < 6,
    6 ka NSE hai 2
    pop kiya 
    6 ka PSE hai 5 kyuki 2 k pop k baad ab 5 peek tha

    6 ka karykram nipatne k baad 5 ki bari
    5 > 2 5 ka NSE 2 hai
    pop kiya top pr 1 hai, 5 ka PSE 1

    ab ruk gaya

    ab stack k top pr 1 aur push krnge 2 ko
    i bada ab 3 last index pr hai push kiya

    game over

    hamne dekha ki stack me kuch elements bach rahe so 

    ab ek ek krne inki kahani dekho 3 ka NSE -1 aa raha so usko n - size of array kr do (hypothetical index)
    3 ko pop kiya to 2 mila , PSE of 3 is 2

    ab 2 k liye kro same aur last me 1 vishay khatam

    har ek step me bss area aur maxArea vala kaam krna hai

    area = heights[i] x (NSE[i] - PSE[i] - 1)

*/
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;

        int maxArea = 0;
        int area = 0;

        Stack<Integer> st = new Stack<>();

        int top = -1;
        int NSE = -1;
        int PSE = -1;

        for(int i = 0; i < n; i++)
        {
            while(!st.isEmpty() && heights[st.peek()] > heights[i])
            {
                NSE = i;

                top = st.pop();

                PSE = st.isEmpty() ? - 1 : st.peek();

                area = heights[top] * (NSE - PSE - 1);

                maxArea = Math.max(maxArea, area);    
            }

            st.push(i);
        }

        while(!st.isEmpty())
        {
            NSE = n;

            top = st.pop();

            PSE = st.isEmpty() ? -1 : st.peek();
            
            area = heights[top] * (NSE - PSE - 1);

        	maxArea = Math.max(area, maxArea);
                    
        }

        return maxArea;
    }
}
