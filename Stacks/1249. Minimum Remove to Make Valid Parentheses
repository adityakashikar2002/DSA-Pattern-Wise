Approach 1 - Using Stack & HashSet - (Brute)
// Time: O(3n) ~ O(n)
// Space: O(3n) ~ O(n)
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
/*
    sabse asan tarika hoga ki, ek stack me jaise valid parentheses lete vaise kro push and pop vala kaam
    but iss baar '(' ye push krne k bajah, index push kro uska
    agar stack empty nhi rahta matlab '(' yee additional kahi to bhi aya hai
    same goes for if stack empty ho gaya lekin ')' bach jata hai matlab closing brace jyada hai, uska index store kro
    bss phir ek new string banao jisme yee indexes apn skip krenge
    store krne k liye HashSet le lo taki lookup O(1) me ho jaye
*/
class Solution {
    public String minRemoveToMakeValid(String s) {
        int n = s.length();

        Stack<Integer> st = new Stack<>(); // '(' k indexes store krenge stack me 
        Set<Integer> set = new HashSet<>(); // yaha sare bache hue indexes store krenge jo skip krne hai

        for(int i = 0; i < n; i++)
        {
            char ch = s.charAt(i);

            if(ch >= 'a' && ch <= 'z') // agar a-z k beech k char aye to skip maro
                continue;
            else if(ch == '(')  // agar '(' mila to uska index stack me dalo
                st.push(i);
            else
            {
                if(st.isEmpty()) // stack empty hai aur ')' mila hai to ')' additional hai, iska index store kro
                    set.add(i);
                else
                {
                    st.pop();  // agar stack empty nhi hai matlab usme '(' ka index hai match hua so pop
                }
                
            }
        }

        while(!st.isEmpty()) // jab tak stack empty nhi hota uske sare indexes set me dalo
        {
            set.add(st.pop());
        }

        StringBuilder res = new StringBuilder("");

        for(int i = 0; i < n; i++) // skip krne vale indexes k characters ko resultant string me skip kro
        {
            char c = s.charAt(i);

            if(!set.contains(i))
                res.append(c);
        }

        return res.toString();
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
Approach 2 - Using Two Pass Method - (Better)
// Time: O(2n) ~ O(n)
// Space: O(n) ~ O(1) (if we ignore the resultant string auxiliary space)
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------

/**
    dursa tarika hai agar space ko eliminate krna hai (bina stack aur set k)
    two pass solution
    1st pass me left to right scan krk pata krnge ki kya koi extra ')' hai kya
    2nd pass me 1st pass ki resultant string ko right se left scan krnge ki koi extra '(' hai kya
    simple idea hai, jo extra mila usko skip kr denge
*/
class Solution {
    public String minRemoveToMakeValid(String s) {
        int n = s.length();

        int open = 0;
        int close = 0;

        StringBuilder str = new StringBuilder("");

        // First Pass Left -> Right checks for extra ')'
        for(int i = 0; i < n; i++)
        {
            char ch = s.charAt(i);
            
            if(ch >= 'a' && ch <= 'z') // a-z to append marna hai hai
                str.append(ch);
            else if(ch == '(') // open brace mila to open ka count badao aur uska append kro
            {
                open++;
                str.append(ch);
            }
            else if(open > 0) // agar closing brace mila to kya opening brace hai ? agar hai to isko bhi append krenge
            {                 // kyuki match hogaya so invalid parentheses to nhi hai
                open--;
                str.append(ch);
            }
            else // agar ye uppar se koi match nhi hota aur jab hamare paas bss ')' brace hai
            {    // without any open brace available so yee invalid ho jaega so.. skip maro
                continue; // vaise else part likhne ki garaj nhi ðŸ˜…
            }

        }

        StringBuilder res = new StringBuilder("");

        // Second Pass Right -> Left  checks for extra '(' same kaam in opposite direction
        for(int i = str.length() - 1; i >= 0; i--)
        {

            char ch = str.charAt(i);

            if(ch >= 'a' && ch <= 'z')
                res.append(ch);
            else if(ch == ')')
            {   
                close++;
                res.append(ch);
            }
            else if(close > 0)
            {
                close--;
                res.append(ch);
            }
            else
            {
                continue;
            }
        }


        return res.reverse().toString(); // kyuki append kiya tha isliye pahle reverse krna padega
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
Approach 3 - Using Two Pass Method - (Slightly More Better)
// Time: O(2n) ~ O(n)
// Space: O(n) ~ O(1) (if we ignore the resultant string auxiliary space)
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------

/**
    theesra tarika hai two pass solution but slight change
    1st pass me open ki value count kr lete 
    2nd pass me right to left scan krte vakht jitne open hai unko skip marne ka append hi mat kro
    
*/
class Solution {
    public String minRemoveToMakeValid(String s) {
        int n = s.length();

        int open = 0;

        StringBuilder str = new StringBuilder("");

        // First Pass Left -> Right checks for extra ')'
        for(int i = 0; i < n; i++)
        {
            char ch = s.charAt(i);
            
            if(ch >= 'a' && ch <= 'z') // a-z to append marna hai hai
                str.append(ch);
            else if(ch == '(') // open brace mila to open ka count badao aur uska append kro
            {
                open++;
                str.append(ch);
            }
            else if(open > 0) // agar closing brace mila to kya opening brace hai ? agar hai to isko bhi append krenge
            {                 // kyuki match hogaya so invalid parentheses to nhi hai
                open--;
                str.append(ch);
            }

        }

        StringBuilder res = new StringBuilder("");

        // Second Pass Right -> Left  checks for extra '(' same kaam in opposite direction
        for(int i = str.length() - 1; i >= 0; i--)
        {

            char ch = str.charAt(i);

            if(ch >= 'a' && ch <= 'z' || ch == ')')
                res.append(ch);
            else if(ch == '(' && open > 0) // agar yee extra vala mila to skip mara count decrement kr di
            {   
                open--;
            }
            else              // ab kuch nhi ab '(' ye aya to append kr skhte
            {
                res.append(ch);
            }
        }


        return res.reverse().toString(); // kyuki append kiya tha isliye pahle reverse krna padega
    }
}
