// Brute Approach - Simulation (Accepts)
// Time: O(n)
// Space: O(n)
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
/*
    Sabse asan cheez hogi simulate krna bss kuch rules ko follow krna hoga
    1) Continuous Left L, L, L... no collision
    2) Continuous Right R, R, R... no collision
    3) R hitting L or L hitting R same thing +2 collisions
    4) R hitting S (stationary) +1 collision
    5) L hitting S +1 collision
    6) S hitting S no collision

    After collision between any two cars currCar will become S
    kyuki car thokne k baad ruk jati hai (stationary)

    ab logic yee hai 
        R x L ---> collision currCar = S
        R x S ---> collision currCar = S
        L x S ---> collision currCar = S
    
    hame prevCar ka track rakhna hai so kya kaam aa skhta kyuki hum push pop vala kaam kr rahe so stack

    bss yehi simulate krna hai seedhe basha me bola jaye to prevCar kabhi bhi 'L' nhi ho skhti
    vo 'R' ya 'S' hi hogi

    'R' hai to sidha push kro chalne do
    agar 'L' ya 'S' hai to shayad yee collide ho so ekdam push mat kro 'R' se so uske cases handle kro
*/
class Solution {
    public int countCollisions(String directions) {
        Stack<Character> st = new Stack<>();
        int collisions = 0;

        for (char car : directions.toCharArray()) 
        {
            // For 'R' just push
            if (car == 'R') 
            {
                st.push(car);
            } 
            else // car == 'L' or 'S'
            { 
                // Collisions happen while stack has cars that can hit this car
                while (!st.isEmpty() && st.peek() == 'R') 
                {
                    st.pop();        // R will collide
                    collisions++;    // R collided once with car == S
                    if (car == 'L')  // If L came toward R
                        collisions++; // add one more (2 collisions)
                    car = 'S';       // After any collision, result becomes stationary
                }

                // If stationary car on stack and new L comes toward it
                if (!st.isEmpty() && st.peek() == 'S' && car == 'L') 
                {
                    collisions++;    // L hits stationary â†’ 1 collision
                    car = 'S';       // becomes stationary
                }

                st.push(car);
            }
        }
        
        return collisions;
    }
}
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------

// Optimal Approach - Two Pointers
// Time: O(n)
// Space: O(1)
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
/*
    Ab rules to malum hai 
    ek chota sa example lete hai

    Ex:- LLRSLRR

    isko dekho collisions = 2 hai R x S and L x S bss matlab RSL itna hi string valid answer me contribute kiya

    kyuki continous left in beginning kabhi contribute nhi krta so trim
    same goes for continous series of R in the ending
    so aise cases me trim kr do

    abhi LLRSLRR me S nhi bhi hota to bhi answer 2 hi hota LLRLRR LL, RR trim kr diye,
    bacha RL jo valid rahenga 

    yee example lete
    Ex:- RLRSLL

    isme trim ki garaj nhi 
    to apn pure string ko scan marenge aur R,L aya to collisions ka count badaenge
    R-L collisions += 2 (vaise bhi do hi cars hai so 2 hi rahega)
    S ko skip maar skhte kyuki R ne S ko thoka phir L se S ko thoka
    usse achha R ne sidha L to thoka thoda futuristic ðŸ˜‚

    bss two pointers lagana hai
*/
class Solution {
    public int countCollisions(String directions) {
        int collisions = 0;

        int n = directions.length();

        int left = 0;
        int right = n - 1;

        // Ignore left-going cars on left border
        while (left < n && directions.charAt(left) == 'L')
            left++;

        // Ignore right-going cars on right border
        while (right >= 0 && directions.charAt(right) == 'R')
            right--;

        for(int x = left; x <= right; x++)
        {
            char ch = directions.charAt(x);

            if(ch != 'S')
                collisions++;
        }

        return collisions;
    }
}
