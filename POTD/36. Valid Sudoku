// Brute Approach
----------------------------------------------------------------------------------------------------------------
Time Complexity

We are checking:

Every row â†’

    There are 9 rows, and for each row we scan 9 cells â†’ O(9 Ã— 9) = O(81)

Every column â†’

    There are 9 columns, and for each column we scan 9 cells â†’ O(81)

Every 3Ã—3 box â†’

    There are 9 boxes, and for each box we scan 9 cells â†’ O(81)

So total work:

    O(81 + 81 + 81) = O(243) â‰ˆ O(1)


ðŸ‘‰ Why O(1)?
Because the Sudoku board is always fixed at 9Ã—9. Even though we wrote loops, they only ever run for a constant number of iterations (â‰¤ 243). So itâ€™s constant time.

ðŸ”¹ Space Complexity

We use a HashSet<Character> for each row, each column, and each box.

The maximum size of a set is 9 (since only digits 1â€“9 go in).

We donâ€™t store all sets together; we reuse them in loops.

So extra space:

O(9) = O(1)


ðŸ‘‰ Constant space too, since it does not grow with input size.

âœ… Final Answer
----------------------------------------------------------------------------------------------------------------
Time Complexity: O(1) (since board size is fixed 9Ã—9, otherwise O(N^2) for an NÃ—N Sudoku)
Space Complexity: O(1)
----------------------------------------------------------------------------------------------------------------
class Solution {
    public static boolean checkBox(int sr, int er, int sc, int ec, char[][] box)
    {
        HashSet<Character> set = new HashSet<>();

        for(int row = sr; row <= er; row++)
        {
            for(int col = sc; col <= ec; col++)
            {
                char ch = box[row][col];

                if(ch == '.')
                    continue;
                
                if(set.contains(ch))
                    return false;
                
                set.add(ch);
            }
        }

        return true;
    }

    public boolean isValidSudoku(char[][] board) {
        // brute force idea hoga ki har row, har column, aur ha 3 x 3 box me check kro Set leke 

        HashSet<Character> set;

        // checking every row
        for(int row = 0; row < 9; row++)
        {
            set = new HashSet<>();

            for(int col = 0; col < 9; col++)
            {
                char ch = board[row][col];

                if(ch == '.')
                    continue;
                
                if(set.contains(ch))
                    return false;

                set.add(ch);
        
            }
        }

        // checking every col
        for(int col = 0; col < 9; col++)
        {
            set = new HashSet<>();

            for(int row = 0; row < 9; row++)
            {
                char ch = board[row][col];

                if(ch == '.')
                    continue;
                
                if(set.contains(ch))
                    return false;
                
                set.add(ch);
        
            }
        }

        // checking every 3 x 3 box

        for(int sr = 0; sr <= 6; sr += 3)
        {
            int er = sr + 2; // ending row

            for(int sc = 0; sc <= 6; sc += 3)
            {
                int ec = sc + 2; // ending column

                boolean valid = checkBox(sr, er, sc, ec, board); // agar traverse kiya aur false mila matlab invalid

                if(!valid)
                    return false;
            }
        }

        return true;
    }
}

----------------------------------------------------------------------------------------------------------------
// Better Approach
----------------------------------------------------------------------------------------------------------------
ðŸ”¹ Time Complexity

We loop through each cell in the 9Ã—9 board:

for (int r = 0; r < 9; r++) {
    for (int c = 0; c < 9; c++) {
        ...
    }
}


Thatâ€™s 81 iterations.

Inside the loop we do constant-time operations: string creation, set lookup, and set insertion â†’ each O(1) on average for a HashSet.

So total work:

O(81 Ã— 1) = O(81) â‰ˆ O(1)


ðŸ‘‰ Constant time because Sudoku board size is fixed.
If this were a general NÃ—N Sudoku, it would be:

O(N^2)

ðŸ”¹ Space Complexity

You use a HashSet<String> to store constraints.

Each cell (at most 81 non-empty ones) can generate 3 strings (row, col, box).

So worst case: 81 Ã— 3 = 243 strings in the set.

Thatâ€™s O(243) â‰ˆ O(1) extra space.
(For general NÃ—N Sudoku â†’ O(N^2).)

âœ… Final Answer

Time Complexity: O(1) (constant, since board is always 9Ã—9)

Space Complexity: O(1) (constant, at most 243 strings in the set)
---------------------------------------------------------------------------------------------------------------------------------------------------

class Solution {
    public boolean isValidSudoku(char[][] board) {

        HashSet<String> set = new HashSet<>();

        for(int r = 0; r < 9; r++)
        {
            for(int c = 0; c < 9; c++)
            {
                char ch = board[r][c];

                if(ch == '.')
                    continue;
                
                int row = r / 3;
                int col = c / 3;

                String rows = ch + " is at row " + r;
                String cols = ch + " is at col " + c;
                String pos = ch + " is at " + row + " - " + col;

                if(set.contains(rows) || set.contains(cols) || set.contains(pos))
                    return false;

                set.add(rows);
                set.add(cols);
                set.add(pos);
            }
        }

        return true;
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------
// Optimal Approach
---------------------------------------------------------------------------------------------------------------------------------------------------
rows[r][num] â†’ "Has this number appeared in this row?"

cols[c][num] â†’ "Has this number appeared in this column?"

boxes[boxIndex][num] â†’ "Has this number appeared in this 3Ã—3 box?"

Now, given a cell (r, c):

(r / 3) â†’ tells us which row of boxes we are in (0,1,2).

(c / 3) â†’ tells us which col of boxes we are in (0,1,2).

So we combine them:

boxIndex = (r / 3) * 3 + (c / 3)


ðŸ‘‰ Example:

Cell (0,0) â†’ (0/3)*3 + (0/3) = 0 â†’ top-left box.

Cell (4,7) â†’ (4/3)*3 + (7/3) = 1*3 + 2 = 5 â†’ middle row, right box.

Cell (8,8) â†’ (8/3)*3 + (8/3) = 2*3 + 2 = 8 â†’ bottom-right box.

So each cell is correctly mapped to one of the 9 boxes.

If any is already true â†’ duplicate found â†’ invalid Sudoku.

Time Complexity:
We scan each cell once â†’ 81 iterations â†’ O(1) (constant).
For a generalized NÃ—N Sudoku â†’ O(N^2).

Space Complexity:
rows[9][9], cols[9][9], boxes[9][9] = 3 Ã— 81 = 243 booleans â†’ O(1) (constant).
For generalized NÃ—N â†’ O(N^2).
------------------------------------------------------------------------------------------------------------------------------------------------------

class Solution {
    public boolean isValidSudoku(char[][] board) {

        boolean[][] rows = new boolean[9][9];
        boolean[][] cols = new boolean[9][9];
        boolean[][] boxes = new boolean[9][9];

        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                char ch = board[r][c];

                if (ch == '.') continue; // skip empty cells

                int num = ch - '1'; // convert '1'..'9' â†’ 0..8
                int boxIndex = (r / 3) * 3 + (c / 3);

                if (rows[r][num] || cols[c][num] || boxes[boxIndex][num]) {
                    return false; // duplicate found
                }

                rows[r][num] = true;
                cols[c][num] = true;
                boxes[boxIndex][num] = true;
            }
        }

        return true;
    }
}
