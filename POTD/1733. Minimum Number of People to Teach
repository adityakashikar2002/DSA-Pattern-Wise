// Time: O(m x n)
// Space: O(m x n)
---------------------------------------------------------------------------------------------------------------------
class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        
        int m = languages.length; // users

        List<Set<Integer>> userLanguages = new ArrayList<>();

        // find which user knows which languages
        for(int i = 0; i < m; i++)
        {
            Set<Integer> set = new HashSet<>();
            
            for(int lang : languages[i])
            {
                set.add(lang);
            }

            userLanguages.add(set);
        }

        // find problematic pairs

        Set<Integer> problematicUsers = new HashSet<>();

        for(int[] f : friendships)
        {
            int u = f[0] - 1;
            int v = f[1] - 1;

            boolean canCommunicate = false;

            for(int lang: userLanguages.get(u))
            {
                if(userLanguages.get(v).contains(lang))
                {
                    canCommunicate = true;
                    break;
                }
            }

            if (!canCommunicate) 
            {
                problematicUsers.add(u);
                problematicUsers.add(v);
            }
        }

        // If no problematic users, return 0
        if (problematicUsers.isEmpty()) 
        {
            return 0;
        }

        // For each language, count how many problematic users already know it
        int minTeach = Integer.MAX_VALUE;

        for (int lang = 1; lang <= n; lang++) {
            int teachCount = 0;
            for (int user : problematicUsers) {
                if (!userLanguages.get(user).contains(lang)) {
                    teachCount++;
                }
            }
            minTeach = Math.min(minTeach, teachCount);
        }

        return minTeach;
        
    }
}
