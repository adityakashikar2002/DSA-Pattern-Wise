// Brute Approach
// Time:- O(nÂ²)
// Space;- O(1) -> ignoring the res ArrayList
---------------------------------------------------------------------
class Solution {
    public ArrayList<Integer> farMin(int[] arr) {
        int n = arr.length;

        ArrayList<Integer> res = new ArrayList<>();

        for(int i = 0; i < n; i++)
        {
            int f = -1;
            for(int j = i + 1; j < n; j++)
            {
                if(arr[j] < arr[i])
                {
                    f = j;
                }
            }

            res.add(f);
        }

        return res;
    }
}
---------------------------------------------------------------------
// Optimal - Binary Search + Suffix Array
// Time:- O(n logn)
// Space;- O(n) -> Suffix Array (n)
---------------------------------------------------------------------
class Solution {
    public ArrayList<Integer> farMin(int[] arr) {
        // Code Here
        
        int n = arr.length;
        
        ArrayList<Integer> res = new ArrayList<>();
        
        int[] suffixArr = new int[n];
        
        suffixArr[n - 1] = arr[n - 1];
        
        // 2 5 1 3 2 -> OG Arr
        // 1 1 1 2 2 -> suffixArr
        
        // store the min ele from right , suffix array
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] < suffixArr[i + 1])
            {
                suffixArr[i] = arr[i];
            }
            else
            {
                suffixArr[i] = suffixArr[i + 1];
            }
        }
        
        // use binary search to find the farthest smallest ele
        
        for(int i = 0; i < n; i++)
        {
            int f = -1;
            
            int low = i + 1;
            int high = n - 1;
            
            while(low <= high)
            {
                int mid = (low + high) / 2;
                
                if(suffixArr[mid] < arr[i])
                {
                    // we can look for better farthest ele so
                    f = mid;
                    low = mid + 1;
                }
                else
                {
                    high = mid - 1;
                }
            }
            
            res.add(f);
        }
        
        return res;
    }
}
