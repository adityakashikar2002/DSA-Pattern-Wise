// Brute Approach - Find maxConsecutive Ones in all subarrays possible
// Time: O(nÂ²)
// Space: O(1)
---------------------------------------------------------------------------------------------
class Solution {
    public int maxOnes(int arr[], int k) {
        // code here
        
        int n = arr.length;
        int maxOnes = -1;
        
        for(int i = 0; i < n; i++)
        {
            int x = k;
            
            for(int j = i; j < n; j++)
            {
                if(arr[j] == 0) // when zero is there we flip so decrement x
                {
                    if(x == 0) // if its already zero we can't flip so break
                        break;
                    else
                        x--;
                }
                
                maxOnes = Math.max(maxOnes, j - i + 1); // always keeps track of maxConsecutive ones
            }
        }
        
        return maxOnes;
    }
}

---------------------------------------------------------------------------------------------

// Better Approach - Sliding Window
// Time: O(2n) ~ O(n)
// Space: O(1)
---------------------------------------------------------------------------------------------

class Solution {
    public int maxOnes(int arr[], int k) {
        // code here
        int n = arr.length;
        
        int maxConsecutiveOnes = -1;
        
        int countZero = 0;
        
        int i = 0;
        int j = 0;
        
        while(j < n)
        {
            if(arr[j] == 0)
            {
                countZero++;
            }
            
            while(countZero > k)
            {
                if(arr[i] == 0)
                    countZero--;
                
                i++;
            }
            
            maxConsecutiveOnes = Math.max(maxConsecutiveOnes, j - i + 1);
            
            j++;
        }
        
        return maxConsecutiveOnes;
    }
}

---------------------------------------------------------------------------------------------
// Optimal Approach - Sliding Window (Without Inner While Loop)
// Time: O(n)
// Space: O(1)
---------------------------------------------------------------------------------------------

class Solution {
    public int maxOnes(int arr[], int k) {
        // code here
        int n = arr.length;
        
        int maxConsecutiveOnes = -1;
        
        int countZero = 0;
        
        int i = 0;
        int j = 0;
        
        while(j < n)
        {
            if(arr[j] == 0)
            {
                countZero++;
            }
            
            if(countZero > k)
            {
                if(arr[i] == 0)
                    countZero--;

                i++;            // just move one step forward in order to maintain the maximum consectutive ones' length so far, we in simple are looking for a better answer 
            }
            
            maxConsecutiveOnes = Math.max(maxConsecutiveOnes, j - i + 1);
            
            j++;
        }
        
        return maxConsecutiveOnes;
    }
}
