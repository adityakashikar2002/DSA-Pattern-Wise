// Brute Approach
// Time: O(nÂ²)
// Space: O(3) ~ O(1)
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
/**
    sabse brute approach ki har ek ped se suru krenge aur dekhenge ki kitne fruits collect kr skhte hai
    dekha jaye to problem reduce hota hai 
    find longest contiguous subarray with 2 distinct numbers

    to apn Set ka istemaal krenge jab set ka size > 2 chala jayega apn tab break kr denge
*/
class Solution {
    public int totalFruit(int[] fruits) {
        int n = fruits.length;

        int maxFruits = 0;

        for(int i = 0; i < n; i++)
        {
            int collectedFruits = 0;
            Set<Integer> set = new HashSet<Integer>();
            
            for(int j = i; j < n; j++)
            {
                set.add(fruits[j]); 

                if(set.size() > 2)
                    break;
                
                collectedFruits++;
                maxFruits = Math.max(maxFruits, collectedFruits);
            }
        }

        return maxFruits;
    }
}
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------

// Better Approach - Use Sliding Window
// Time: O(n + n) ~ O(n)
// Space: O(3) ~ O(1)
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
/**
    brute force jyada time lega to kya apn fixed sized sliding window use kr skhte hai
    definitely, hum ek HashMap me sare types k trees ka count rakhenge 
    jab map ka size > 2 hoga tab phir left se shrink krte jaenge jab tak phir se
    window valid nhi hota map.size() <= 2 jab kisi tree ka count zero ho jaega apn usko
    map me se remove kr denge

*/
class Solution {
    public int totalFruit(int[] fruits) {
        int n = fruits.length;

        int maxFruits = 0;
        int collectedFruits = 0;

        HashMap<Integer, Integer> fruitCount = new HashMap<>();

        int l = 0;
        for(int r = 0; r < n; r++)
        {
            int fruit = fruits[r];

            if(fruitCount.containsKey(fruit))
            {
                fruitCount.put(fruit, fruitCount.get(fruit) + 1);
            }
            else
            {
                fruitCount.put(fruit, 1);
            }


            while(fruitCount.size() > 2)
            {
                int leftFruit = fruits[l++];

                fruitCount.put(leftFruit, fruitCount.get(leftFruit) - 1);
                
                if(fruitCount.get(leftFruit) == 0)
                    fruitCount.remove(leftFruit);
            }

            maxFruits = Math.max(maxFruits, r - l + 1);
        }

        return maxFruits;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
// Optimal Approach - Sliding Window No Inner While loop
// Time: O(n)
// Space:O(3) ~ O(1)
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
/**
    sliding window bhi sahi lekin ek problem hai
    worst case me do baar pura traverse krta hai so apn aisa krenge bss ek baar shrink krenge taki hum maximum
    subarray nikal skhe, kyuki curr window ki len decrease krk matlab nhi so.. bss ek baar shrink krenge

*/
class Solution {
    public int totalFruit(int[] fruits) {
        int n = fruits.length;

        int maxFruits = 0;
        int collectedFruits = 0;

        HashMap<Integer, Integer> fruitCount = new HashMap<>();

        int l = 0;
        for(int r = 0; r < n; r++) {
            // expand right pointer
            int fruit = fruits[r];
            
            fruitCount.put(fruit, fruitCount.getOrDefault(fruit, 0) + 1);

            // shrink if more than 2 fruit types
            if(fruitCount.size() > 2) 
            {
                int leftFruit = fruits[l++];

                fruitCount.put(leftFruit, fruitCount.get(leftFruit) - 1);

                if(fruitCount.get(leftFruit) == 0)
                    fruitCount.remove(leftFruit);
            }

            // update max window size
            maxFruits = Math.max(maxFruits, r - l + 1);
        }

        return maxFruits;
    }
}
