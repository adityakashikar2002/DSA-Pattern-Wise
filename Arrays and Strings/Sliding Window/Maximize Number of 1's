// Brute Approach
// Time: O(nÂ²)
// Space: O(1)
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
class Solution {
    public int maxOnes(int arr[], int k) {
        // code here
        int n = arr.length;
        int maxRes = 0;
        
        for(int i = 0; i < n; i++)
        {
            int countZeroes = 0;
            int countOnes = 0;
            
            for(int j = i; j < n; j++)
            {
                if(arr[j] == 0)
                    countZeroes++;
                
                if(countZeroes > k)
                {
                    break;
                }
                
                countOnes = j - i + 1;
                maxRes = Math.max(maxRes, countOnes);
            }
        }
        
        return maxRes;
    }
}

--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
// Optimal Approach - Sliding Window
// Time: O(n)
// Space: O(1)
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
class Solution {
    public int maxOnes(int arr[], int k) {
        // code here
        int n = arr.length;
        int maxRes = 0;
        
        int countZeroes = 0;
        int countOnes = 0;
        
        int l = 0;    
        for(int r = 0; r < n; r++)
        {
            if(arr[r] == 0)
                countZeroes++;
            
            while(countZeroes > k)
            {
                if(arr[l] == 0)
                    countZeroes--;
                
                l++;
            }
            
            countOnes = r - l + 1;
            maxRes = Math.max(maxRes, countOnes);
        }
        
        return maxRes;
    }
}
