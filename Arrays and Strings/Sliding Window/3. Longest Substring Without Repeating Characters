// Brute Force
// Time: O(nÂ²)
// Space: O(n)
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

/**
    sabse asan tarika hoga ki har ek substring check marte hai
    ek set lee lete jisme string k characters dalte rahenge unique vale
    agar set se koi character repeat hota hai to maxLen udpate krk break kr denge
    aur new substring me dekhenge; 
*/
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        
        int maxLen = 0;

        for(int i = 0; i < n; i++)
        {
            Set<Character> set = new HashSet<>();
            int currLen = 0;

            for(int j = i; j < n; j++)
            {
                char ch = s.charAt(j);
                
                if(set.contains(ch))
                {
                    break;
                }
                else
                {
                    set.add(ch);
                    currLen++;
                }
                    
            }

            maxLen = Math.max(maxLen, currLen);

        }

        return maxLen;
    }
}
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
// Better Approach - Fast in O(n)
// Time: O(n)
// Space: O(n)
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

/**
    ek tarika yee ho skhta hai ki hum ek sliding window lee lenge
    jab bhi curr window me koi repeated char ayega to hum maxLen update krk
    shrink kr denge

    Set ka kaam to padega hi
*/
class Solution {
    public int lengthOfLongestSubstring(String s) 
    {
        int n = s.length();
        int maxLen = 0;
        Set<Character> window = new HashSet<>();

        int left = 0;
        for (int right = 0; right < n; right++) 
        {
            char ch = s.charAt(right);

            // shrink window until current char is unique
            while (window.contains(ch)) 
            {
                window.remove(s.charAt(left));
                left++;
            }

            window.add(ch);
            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;
    }
}
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

// Optimal Approach - Best runtime no need to remove left ele one by one direct jump
// Time: O(n)
// Space: O(n)
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
/**
    Set use krne se ek problem hoti hai ki left ko ek-ek krk
    shrink krna pdta hai usse acha hum direct jump krnge

    like jab curr window me curr char repeat hua to uski index value + 1 pr left ko jump
    kra denge aur maxLen to update hota rahega hi
*/
class Solution {
    public int lengthOfLongestSubstring(String s) 
    {
        int n = s.length();
        int maxLen = 0;
        HashMap<Character, Integer> map = new HashMap<>();

        int left = 0;
        int right = 0;

        while(right < n)
        {
            char ch = s.charAt(right);

            if(map.containsKey(ch) && map.get(ch) >= left)
                left = map.get(ch) + 1;

            map.put(ch, right);
            maxLen = Math.max(maxLen, right - left + 1);

            right++;
        }

        return maxLen;
    }
}
