// Time: - O(k)
// Space: - (1)
----------------------------------------------------------------------------
class Solution {
    public int kthElement(int a[], int b[], int k) {
        // code here
        int a_len = a.length;
        int b_len = b.length;
        
        int i = 0;
        int j = 0;
        int ele = -1;
        int count = 0;
        
        while(count != k && i < a_len && j < b_len)
        {
            if(a[i] <= b[j])
            {
                ele = a[i];
                i++;
            }
            else
            {
                ele = b[j];
                j++;
            }
            
            count++;
        }
        
        if(count == k)
            return ele;
        
        while(j < b_len && count != k)
        {
            ele = b[j];
            j++;
            count++;
        }
        
        while(i < a_len && count != k)
        {
            ele = a[i];
            i++;
            count++;
        }
        
        return ele;
    }
}

----------------------------------------------------------------------------
// Time: - O(log(min(n,m)
// Space: - (1)
----------------------------------------------------------------------------

class Solution {
    public int kthElement(int a[], int b[], int k) {
        // code here
        int n1 = a.length;
        int n2 = b.length;
        
        // always choose small array to do binary search
        
        int low = Math.max(k - n2, 0); // can't go beyond 0 and also can't choose less than k - n2 so
        int high = Math.min(k, n1);  // Pick from a[] what b[] can't, but never more than a[] has
        
        while(low <= high)
        {
            int mid1 = (low + high) / 2;
            int mid2 = k - mid1;
            
            int l1 = Integer.MIN_VALUE;
            int l2 = Integer.MIN_VALUE;
            
            int r1 = Integer.MAX_VALUE;
            int r2 = Integer.MAX_VALUE;
            
            if(mid1 < n1)
                r1 = a[mid1];
            if(mid2 < n2)
                r2 = b[mid2];
            
            if(mid1 - 1 >= 0)
                l1 = a[mid1 - 1];
            if(mid2 - 1 >= 0)
                l2 = b[mid2 - 1];
                
            if(l1 <= r2 && l2 <= r1)
            {
                return Math.max(l1, l2);
            }
            else if(l1 > r2)
            {
                high = mid1 - 1;
            }
            else
            {
                low = mid1 + 1;
            }
        }
        
        return 0;
    }
}
