// Time: O(n)
// Space: O(1)
--------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
/**
 * Problem: Given a sorted array, remove duplicates such that each element appears at most twice.
 * We must modify the array in-place and return the new length (k).
 *
 * Intuition:
 *  Since array already sorted hai, saare duplicates ek saath milenge.
 *  Hum ek write-pointer (i) rakhenge jo batayega ki ab tak kitne valid elements rakhe gaye.
 *  
 *  Rule:
 *  - Agar array me abhi tak 0 ya 1 element hi add kiye hain, to current element ko seedha add kar denge.
 *  - Lekin jab humare paas 2 ya zyada elements ho jaye, tab hume check karna padega:
 *        Agar current element same hai jaisa 2 position pehle add hua tha (nums[i-2]),
 *        to iska matlab ye element already 2 baar aa chuka hai â†’ isko skip kar do.
 *        Warna isko add kar do.
 *
 *  Is logic se har element max 2 times hi array me reh payega.
 */
class Solution {
    public int removeDuplicates(int[] nums) {
        int i = 0; // write pointer
        
        for(int num : nums) 
        { 

            // Pehle 2 elements bina soche rakho,

            // uske baad check karo ki current 3rd duplicate to nahi.
            if(i < 2 || num != nums[i - 2]) 
            {
                nums[i] = num;
                i++;
            }
        }
        
        return i; // i hi valid length (k) dikhata hai
    }
}
