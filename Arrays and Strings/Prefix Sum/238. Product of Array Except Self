// Brute Approach
// Time: O(nÂ²)
// Space: O(n)
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
/** 
    sabse brute force tarika hoga ki,
    sare elements pr jaake unko skip krk product lete vakht result array banao
    [1, 2, 3, 4]

    like 3 k vakht 2nd index 3 ko skip marenge product lee lenge
*/
class Solution {
    public int[] productExceptSelf(int[] nums) {
        
        int[] res = new int[nums.length];

        for(int i = 0; i < nums.length; i++)
        {
            int product = 1;

            for(int j = 0; j < nums.length; j++)
            {
                if(i == j)
                    continue;
                
                product *= nums[j];
            }

            res[i] = product;
        }

        return res;
    }
}
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------

// Better Approach - 1 (Using Division)
// Time: O(2n) ~ O(n)
// Space: O(n)
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
/**
    ab hame to yaha without division use krne bola hai
    still yaha division se solve kiya ja skhta hai

    like [1, 2, 3, 4] k liye to kaam kr jaega

    lekin agar [1, 0, 3] k liye bola to gadbad ho jayegi
    Division by 0

    to ap sochenge bss 0 vale ka problem hai n

    to jaha zero hai vaha product without zero lee lo

    1 0 3
    0 3 0

    but yee bhi hamesha kaam nhi krega

    like

    1 0 0 3

    yaha productWithZero = 0, productWithoutZero = 3

    1 0 0 3
    0 3 3 0 yee wrong ho jayega kyuki 2nd zero k liye bhi product zero hi aa raha

    to hum kya kr skhte

    hum yee kah skhte hai agar count of zeroes count > 1 yaha to uss jagah pkka product zero hoga
    agar count of zeroes total array me bss 1 hi hai to productWithout zero ko sidha ans me daal shte

    1 0 0 3
    0 0 0 0 yee correct hai 
*/
class Solution {
    public int[] productExceptSelf(int[] nums) {
        
        int n = nums.length;

        int[] res = new int[n];

        int countZero = 0;
        int productWithoutZeroes = 1;

        for(int i = 0; i < n; i++)
        {
            if(nums[i] == 0)
                countZero++;
            else
                productWithoutZeroes *= nums[i]; 
        }

        for(int i = 0; i < n; i++)
        {
            if(nums[i] != 0)
            {
                if(countZero > 0)
                    res[i] = 0;
                else
                    res[i] = productWithoutZeroes / nums[i];
            }
            else
            {
                if(countZero > 1)
                    res[i] = 0;
                else
                    res[i] = productWithoutZeroes;
            }

        }

        return res;
    }
}
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------

// Better Approach - 2 Using leftPrefixProduct and RightSuffixProduct arrays (Without Division)
// Time: O(3n) ~ O(n)
// Space: O(3n) ~ O(n)
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
/**
    abhi agar division mat use kro bola to ek aur tarika hai
    kya hum aisa nhi kr skhte ki har element k left ka product kya hai 
    aur uske right ka product kya hai ??

    isse yee hoga ki dono taraf k products ka jab product krnge to
    pure arr ka product without that ele milega

    like 

    arr = [1, 2, 3, 4]
    left = [1, 1, 2, 6]

    ab left ka yee kaise aya

    1 k left me koi elements so 1 ka left ka product -> 1
    2 k left me product 1 x 1 hoga so -> 1
    3 k left ka 1 x 2 -> 2
    4 k left ka 2 x 3 -> 6

    right = [24, 12, 4, 1]
    right k liye ulta reverse traverse krenge

    4 k right me koi nhi so -> 1
    3 k right me 1 x 4 -> 4
    2 k right me 4 x 3 -> 12
    1 k right me 12 x 2 -> 24

    bss pointer ghatane ya badane se pahle
    uske next ya prev acc s multiply kr dene ka nhi to curr ele aage yaa peeche k product me nhi ayega

*/
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;

        int[] res = new int[n];

        int[] left = new int[n];
        int[] right = new int[n];

        left[0] = 1;
        right[n - 1] = 1;

        for(int i = 1; i < n; i++)
        {
            left[i] = left[i - 1] * nums[i - 1];
        }

        for(int i = n - 2; i >= 0; i--)
        {
            right[i] = right[i + 1] * nums[i + 1]; 
        }

        for(int i = 0; i < n; i++)
        {
            res[i] = left[i] * right[i];
        }

        return res;
    }
}
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------

// Optimal Approach - Updated Version of LeftProduct and RightProduct array
// Extra Space katta hai
// Time: O(2n) ~ O(n)
// Space: O(2n) ~ O(n)
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
/**
    actually dekha jaye to yee left right product array time aur space bohot
    le raha to kya hum kuch space kam kr skhte hai ?
    definitely kr skhte

    hum sirf leftProduct nikalenge

    aur scan krte vakht hi rightProduct nikal k res me left x right ka product nikalenge 

*/
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;

        int[] res = new int[n];

        int[] left = new int[n];

        left[0] = 1; // kyuki 1st ele k left me koi ele nhi to prod = 1

        for(int i = 1; i < n; i++)
        {
            left[i] = left[i - 1] * nums[i - 1]; // aage k liye  
        }

        int rightProd = 1; // last ele k right me koi nhi so..

        for(int i = n - 1; i >= 0; i--)
        {
            res[i] = rightProd * left[i]; // curr ka prod hoga
            rightProd *=nums[i]; // aage badne se pahle update krnge rightProd ko
        }

        return res;
    }
}
