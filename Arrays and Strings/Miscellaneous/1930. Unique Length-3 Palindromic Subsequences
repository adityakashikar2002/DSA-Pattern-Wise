// Brute Approach
// Time: O(nÂ³)
// Space: O(26 x 26) ~ O(1)

Space Complexity is 26 x 26 as O(1) because palindrome of size 3 is of form
---> X Y X 

for each X there are 26 choices a - z, and for Y also same 26 choices so total in worst case can be 26 x 26 
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
/*
    Brute approach hoga, sare subsequences check kro of size 3, agar palindrome hai 
    1st char = 3rd char, to set me add kro, set duplicates handle krta hi hai 
*/
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        Set<String> set = new HashSet<>();

        for (int i = 0; i < n - 2; i++) 
        {
            for (int j = i + 1; j < n - 1; j++) 
            {
                for (int k = j + 1; k < n; k++) 
                {    
                    // palindrome of length 3 means first == last
                    if (s.charAt(i) == s.charAt(k)) 
                    {
                        String str = "" + s.charAt(i) + s.charAt(j) + s.charAt(k);
                        set.add(str);
                    }
                }
            }
        }

        return set.size();
    }
}
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
// Better Approach - 1 
// Time: O(n + (26 x (n + n))) ~ O(n)
// Space: O(26 + 26) ~ O(1)
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
/*
    Brute Approach to bohot time lega, cubic me j raha kya use achha koi way nhi ??

    main gist of question hai "3-length palindrome"

    3-length palindrome ki khasiyat hai ki 1st aur last char hamehsa same hote hai,
    beech k character ka koi lena dena nhi

    X Y X 

    right ??

    ab question me bola hai ki palindromes repeat nhi hone chaiye

    apn ek kaam kr skte, har ek distinct char in string, uska 1st aur last occurence nikal lenge
    kyuki hame X Y X me X ka 1st aur last occurence chaiye

    phir Y yani middle element jitne honge betwwen 1st and last occurence vo palindrome me contribute krenge
    bss yee middle characters bhi unique hone chaiye

    jaha unique ki baat hai vaha set use krenge 
*/
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        int ans = 0;

        Set<Character> uniqueChar = new HashSet<>();

        for(char ch : s.toCharArray())
            uniqueChar.add(ch);

        int[] first = new int[26];
        int[] last = new int[26];

        Arrays.fill(first, -1);
        Arrays.fill(last, -1);

        for(char ch : uniqueChar)
        {
            for(int i = 0; i < n; i++)
            {
                char curr = s.charAt(i);

                if(curr == ch)
                {
                    if(first[ch - 'a'] == -1)
                    {
                        first[ch - 'a'] = i;
                    }

                    last[ch - 'a'] = i;
                }
            }

            Set<Character> distChar = new HashSet<>();

            for(int middle = first[ch - 'a'] + 1; middle < last[ch - 'a']; middle++)
            {
                distChar.add(s.charAt(middle));
            }

            ans += distChar.size();
        }

        return ans;
    }
}
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
// Better Approach - 2 
// Time: O((26 x (n + n)) ~ O(n)
// Space: O(26) ~ O(1)
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
/*
    kaam vohi krenge lekin apn ko malum hai 
    characters to a - z tak hi rahenge right so kyu unique nikalo phir store kro and all space kam kr skhte apn
*/
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        int ans = 0;

        for(char ch = 'a'; ch <= 'z'; ch++) // direct har char ka 1st, last occur nikalenge
        {

            int first = -1;
            int last = -1;

            for(int i = 0; i < n; i++)
            {
                char curr = s.charAt(i);

                if(curr == ch)
                {
                    if(first == -1)
                    {
                        first = i;
                    }

                    last = i;
                }
            }

            if(first == -1) // agar char string me aya hi nhi to skip maar do
                continue;
            
            Set<Character> distChar = new HashSet<>(); // first aur last occur k bich k chars

            for(int middle = first + 1; middle < last; middle++)
            {
                distChar.add(s.charAt(middle));
            }

            ans += distChar.size();
        }

        return ans;
    }
}
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
// Optimal Approach - Set ko completely remove krk boolean array use kro for counting dist. chars
// Time: O((26 x (n + n))) ~ O(n)
// Space: O(26) ~ O(1)
------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------
/*
    last me distCharacters ko apn set me daal rahe right, usse achha vaha ek boolean array use kr skhte hai
    hi bss vo character already dekha hai ya nhi ??
*/ 
class Solution {
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        int ans = 0;

        for(char ch = 'a'; ch <= 'z'; ch++) // direct har char ka 1st, last occur nikalenge
        {

            int first = -1;
            int last = -1;

            for(int i = 0; i < n; i++)
            {
                char curr = s.charAt(i);

                if(curr == ch)
                {
                    if(first == -1)
                    {
                        first = i;
                    }

                    last = i;
                }
            }

            if(first == -1 || last == first) // agar char string me aya hi nhi to skip maar do
                continue;
            
            boolean[] seen = new boolean[26]; // set ki jagah apn boolean array use krenge

            for(int middle = first + 1; middle < last; middle++)
            {
                seen[s.charAt(middle) - 'a'] = true; // char aya to true 
            }

            for(boolean val : seen)
            {
                if(val)
                {
                    ans++; // jo true hai vo distinct characters honge
                }
            }
        }

        return ans;
    }
}
