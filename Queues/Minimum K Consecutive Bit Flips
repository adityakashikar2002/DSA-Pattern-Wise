// Brute Approach
// Time: O(n x k)
// Space: O(1)
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
class Solution {
    public int kBitFlips(int[] arr, int k) {
        // code here
        int n = arr.length;
        
        int minFlips = 0;
        
        for(int i = 0; i < n; i++)
        {
            // agar already 1 to no flip
            if(arr[i] == 1)
                continue;
            
            if(i + k > n) // window k baher jaa raha to -1 return kr do
                return -1;
                
            for(int j = i; j < i + k; j++)
            {
                arr[j] = arr[j] == 1 ? 0 : 1; // 0 ka 1 , 1 ka 0
                // or arr[j] ^= 1;
            }
            
            minFlips++; // kitne baar flip kiya uska count++
        }
        
        return minFlips;
    }
}

---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
// Better Approach
// Time: O(n)
// Space: O(n)
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
/*
 * -------------------------------------------------------------
 *                MINIMUM K CONSECUTIVE BIT FLIPS
 * -------------------------------------------------------------
 *
 * ğŸ’¡ INTUITION (Problem ko samajhne ka asli tareeka):
 *
 * Hume poora array sirf 1's se bharna hai.
 * Ek operation me hum sirf K consecutive bits flip kar sakte hain.
 *
 * Sabse critical baat:
 *     ğŸ‘‰ Agar hum index i par hai aur arr[i] ko 1 banana hi hai,
 *        toh agar woh effective bit 0 dikhta hai,
 *        toh YAHI PAR flip karna compulsory hai.
 *
 * Kyon?
 * - Kyunki future me jaake tum is bit ko flip nahi kar sakte
 *   (flip window hamesha aage hi badhti hai, peeche nahi).
 * - Aur past ke flips ko tum undo nahi kar sakte.
 *
 * Isi wajah se yeh GREEDY choice ban jaati hai:
 *          "Jahan 0 dikhe, wahi flip start karo."
 *
 * -------------------------------------------------------------
 * ğŸ’¡ PROBLEM KA REAL CHALLENGE:
 * 
 * Direct flip karne se O(n*k) time lagta hai,
 * kyunki har flip me k bits toggle honge.
 *
 * Hume fast me yeh jaan-na hai:
 *
 *      â€œIs index par bit ka REAL value kya hai?
 *       (past flips ko consider karke)â€
 *
 * -------------------------------------------------------------
 * ğŸ’¡ SOLUTION KA CORE IDEA:
 * 
 * 1) Lazy Propagation / Difference-Array Technique:
 *    Hum K-size flip ke ASAR ko direct apply nahi karte.
 *    Bas yeh track karte hain ki:
 *        - Kahan flip start hua,
 *        - Aur kitne flips abhi tak active chal rahe hain.
 *
 * 2) flipCount:
 *    - Kitne flips currently iss index par effect daal rahe hain.
 *    - Agar flipCount odd â†’ bit inverted.
 *    - Agar flipCount even â†’ bit same hai.
 *
 * 3) isFlipped[]:
 *    - yeh track karta hai ki "iss index se flip start kiya tha".
 *    - Jaisi sliding window out hoti hai (i - k), hum flipCount-- kar dete hain.
 *
 * 4) Effective bit calculation:
 *    Effective bit matlab curr bit ko vo value after considering all flip operations
 *
 *        effectiveBit = arr[i] ^ (flipCount % 2)
 *
 *    Agar effectiveBit == 0:
 *        â†’ mandatory flip yahin se
 *        â†’ warna array kabhi 1's nahi ban sakta.
 *
 * -------------------------------------------------------------
 * ğŸ’¡ GREEDY PROOF (Yeh approach optimal kyon hai?):
 *
 * Agar current bit effective 0 hai:
 *    - Agar tum yahan flip nahi karte, toh aage jaa kar
 *      koi bhi flip is bit tak wapas nahi aa sakta.
 *    - Isliye flip yahin karna forced hai.
 *
 * Hum sirf forced flips kar rahe hain â†’ minimum flips guarantee.
 *
 * -------------------------------------------------------------
 * â± TIME COMPLEXITY: O(n)
 *    - Har index ko ek hi baar process kiya jaata hai.
 *
 * -------------------------------------------------------------
 * â³ SPACE COMPLEXITY: O(n)
 *    - isFlipped array ke liye.
 *
 * -------------------------------------------------------------
 */

class Solution {
    public int kBitFlips(int[] arr, int k) {
        int n = arr.length;

        int flipCount = 0;
        int ans = 0;

        int[] isFlipped = new int[n]; // marks where flip starts

        for (int i = 0; i < n; i++) {

            // Remove old flip effect
            if (i >= k) 
            {
                flipCount -= isFlipped[i - k];
            }

            int current = arr[i];
            
            // Apply effect of flips
            if (flipCount % 2 == 1) // flip count odd hai matlab bit 0 / 1 koi bhi change to hone vala hai hi
                current ^= 1;

            if (current == 0) // agar ab yee effective bit 0 hai to isko bhi flip krna padega
            {
                if (i + k > n) 
                    return -1;

                ans++; 
                flipCount++;
                isFlipped[i] = 1;
            }
        }

        return ans;
    }
}

---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
// Optimal Approach
// Time: O(n)
// Space: O(k)
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
/*
 *  âœ” Problem:
 *    Hume har index par yeh check karna hota hai ki
 *    "iss bit par ab tak kitne flips ka effect lag chuka hai?"
 *
 *  âœ” Key Idea:
 *    Flip ka effect **k continuous bits** par lagta hai.
 *    Iska matlab:
 *
 *        i par start hua flip â†’ effect ends at i + k - 1
 *
 *  âœ” Agar hum har flip ko store karte hain, to ek time par
 *    maximum **k flips active** ho sakte hain.
 *
 * -------------------------------------------------------------
 *         â“ Circular Index / Modulo Indexing kyu?
 * -------------------------------------------------------------
 *
 *    â†’ Kyunki hum har iteration me sirf:
 *       1. purana flip effect remove karte hain
 *       2. naya flip add karte hain
 *
 *    â†’ flip ka effect sirf *k steps* tak chalta hai.
 *
 *    â†’ Isliye ek simple array of size k enough hai.
 *
 *    Example:
 *        index = (index + 1) % k
 *
 *    Yeh bilkul waise hi kaam karta hai jaise clock:
 *        0 â†’ 1 â†’ 2 â†’ ... â†’ k-1 â†’ 0 â†’ 1 â†’ 2 ...
 *
 *    ğŸ”¥ Benefit:
 *       â€¢ Memory = O(k)
 *       â€¢ Access = O(1)
 *       â€¢ No extra objects
 */

class Solution {
    public int kBitFlips(int[] arr, int k) {
        int n = arr.length;

        int flipCount = 0;
        int ans = 0;

        // int[] isFlipped = new int[n]; // marks where flip starts
        int[] window = new int[n];
        int index = 0;

        for (int i = 0; i < n; i++) {

            // Remove old flip effect
            if (i >= k) 
            {
                flipCount -= window[index];
            }

            int current = arr[i];
            
            // Apply effect of flips
            if (flipCount % 2 == 1) // flip count odd hai matlab bit 0 / 1 koi bhi change to hone vala hai hi
                current ^= 1;

            if (current == 0) // agar ab yee effective bit 0 hai to isko bhi flip krna padega
            {
                if (i + k > n) 
                    return -1;

                ans++; 
                flipCount++;
                window[index] = 1;
            }
            else
            {
                window[index] = 0;
            }
            
            index = (index + 1) % k;
        }

        return ans;
    }
}
