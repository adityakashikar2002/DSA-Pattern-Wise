// Array (Fixed Size Implementation) of Queue (All operations in O(1) except Dequeue, takes O(n) due to shifting)
public class queue_array
{
	private int queue[];
	private int capacity;
	private int size;
	
	private int front;
	private int rear;
	
	public queue_array(int capacity)
	{
		this.capacity = capacity;
		size = 0;
		front = 0;
		rear = -1;
		queue = new int[capacity];
	}
	
	public void enQueue(int x)
	{
		if(size == capacity)
		{
			System.out.println("Queue is Full !!");
			return;
		}
		
		queue[++rear] = x;
		size++;
	}
	
	public void deQueue()
	{
		if(isEmpty())
			return;
		
		System.out.println("Popped Ele is: " + queue[front]);
		
		for(int i = front + 1; i <= rear; i++)
		{
			queue[i - 1] = queue[i];
		}
		
		size--;
		rear--;
	}
	
	public int getFront()
	{
		return isEmpty() ?  -1 : queue[front];
	}
	
	public int getRear()
	{	
		return isEmpty() ? -1 : queue[rear];
	}
	
	public boolean isEmpty()
	{
		return size == 0;
	}
	
	public int getSize()
	{
		return size;
	}
	
	public void displayQueue()
	{
		if(isEmpty())
		{
			System.out.println("Queue is Empty");
			return;
		}
		
		System.out.print("Queue is: ");
		for(int i = front; i <= rear; i++)
		{
			System.out.print(queue[i] + " ");
		}
		
		System.out.println();
	}
	
	public static void main(String args[])
	{
		queue_array q = new queue_array(10);
		
		q.deQueue();
		q.displayQueue();
		System.out.println("Empty ?: " + q.isEmpty());
		System.out.println("Size of Queue is: " + q.getSize());
		System.out.println("Front Ele is: " + q.getFront());
		System.out.println("Rear Ele is: " + q.getRear());
		
		q.enQueue(5);
		q.enQueue(9);
		q.enQueue(3);
		q.enQueue(7);
		q.enQueue(2);
		q.displayQueue();
		
		q.deQueue();
		q.displayQueue();
		
		System.out.println("\nFront Ele is: " + q.getFront());
		q.displayQueue();
		
		q.deQueue();
		q.displayQueue();
		
		q.enQueue(8);
		q.displayQueue();
		
		System.out.println("Empty ?: " + q.isEmpty());
		System.out.println("Size of Queue is: " + q.getSize());
		System.out.println("Front Ele is: " + q.getFront());
		System.out.println("Rear Ele is: " + q.getRear());
		
		q.deQueue();
		q.displayQueue();
		
		System.out.println("Rear Ele is: " + q.getRear());
		q.displayQueue();
		
	}
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Efficent Array (Fixed Size Implementation) of Queue Using Circular Array (All Operations) in O(1)
public class queue_array_circular
{
	private int queue[];
	private int capacity;
	private int size;
	
	private int front;
	private int rear;
	
	public queue_array_circular(int capacity)
	{
		this.capacity = capacity;
		size = 0;
		front = 0;
		rear = -1;
		queue = new int[capacity];
	}
	
	public void enQueue(int x)
	{
		if(size == capacity)
		{
			System.out.println("Queue is Full !!");
			return;
		}
		
		rear = (rear + 1) % capacity;
		queue[rear] = x;
		size++;
	}
	
	public void deQueue()
	{
		if(isEmpty())
			return;
		
		System.out.println("Popped Ele is: " + queue[front]);
		
		front = (front + 1) % capacity;
		size--;

	}
	
	public int getFront()
	{
		return isEmpty() ?  -1 : queue[front];
	}
	
	public int getRear()
	{	
		return isEmpty() ? -1 : queue[rear];
	}
	
	public boolean isEmpty()
	{
		return size == 0;
	}
	
	public int getSize()
	{
		return size;
	}
	
	public void displayQueue()
	{
		if(isEmpty())
		{
			System.out.println("Queue is Empty");
			return;
		}
		
		System.out.print("Queue is: ");
		for(int i = 0; i < size; i++)
		{
			System.out.print(queue[(front + i) % capacity] + " ");
		}
		
		System.out.println();
	}
	
	public static void main(String args[])
	{
		queue_array_circular q = new queue_array_circular(4);
		
		q.deQueue();
		q.displayQueue();
		System.out.println("Empty ?: " + q.isEmpty());
		System.out.println("Size of Queue is: " + q.getSize());
		System.out.println("Front Ele is: " + q.getFront());
		System.out.println("Rear Ele is: " + q.getRear());
		
		q.enQueue(5);
		q.enQueue(9);
		q.enQueue(3);
		q.enQueue(7);
		q.enQueue(2);
		q.displayQueue();
		
		q.deQueue();
		q.displayQueue();
		
		System.out.println("\nFront Ele is: " + q.getFront());
		q.displayQueue();
		
		q.deQueue();
		q.displayQueue();
		
		q.enQueue(8);
		q.displayQueue();
		
		System.out.println("Empty ?: " + q.isEmpty());
		System.out.println("Size of Queue is: " + q.getSize());
		System.out.println("Front Ele is: " + q.getFront());
		System.out.println("Rear Ele is: " + q.getRear());
		
		q.deQueue();
		q.displayQueue();
		
		System.out.println("Rear Ele is: " + q.getRear());
		q.displayQueue();
		
	}
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// LinkedList Implementation of Queue (Dynamic Size, O(1) operations) 
public class queue_linked_list
{
	class Node
	{
		int data;
		Node next;

		Node(int data)
		{
			this.data = data;
			next = null;
		}
	}
	

	private int size;
	
	Node front;
	Node rear;
	
	public queue_linked_list()
	{
		size = 0;
		front = null;
		rear = null;
	}
	
	public void enQueue(int x)
	{
		Node newNode = new Node(x);
		
		if(front == null && rear == null)
		{
			front = rear = newNode;
		}
		else
		{
			rear.next = newNode;
			rear = rear.next;
		}
		
		size++;
	}
	
	public void deQueue()
	{
		if(isEmpty())
			return;
		
		System.out.println("Popped Ele is: " + front.data);
		
		front = front.next;
		size--;
		
		if(front == null)
			rear = null;

	}
	
	public int getFront()
	{
		return isEmpty() ?  -1 : front.data;
	}
	
	public int getRear()
	{	
		return isEmpty() ? -1 : rear.data;
	}
	
	public boolean isEmpty()
	{
		return size == 0;
	}
	
	public int getSize()
	{
		return size;
	}
	
	public void displayQueue()
	{
		if(isEmpty())
		{
			System.out.println("Queue is Empty");
			return;
		}
		
		Node temp = front;
		System.out.print("Queue is: ");
		while(temp != null)
		{
			System.out.print(temp.data + " ");
			temp = temp.next;
		}
		
		System.out.println();
	}
	public static void main(String args[])
	{
		queue_linked_list q = new queue_linked_list();
		
		q.deQueue();
		q.displayQueue();
		System.out.println("Empty ?: " + q.isEmpty());
		System.out.println("Size of Queue is: " + q.getSize());
		System.out.println("Front Ele is: " + q.getFront());
		System.out.println("Rear Ele is: " + q.getRear());
		
		q.enQueue(5);
		q.enQueue(9);
		q.enQueue(3);
		q.enQueue(7);
		q.enQueue(2);
		q.displayQueue();
		
		q.deQueue();
		q.displayQueue();
		
		System.out.println("\nFront Ele is: " + q.getFront());
		q.displayQueue();
		
		q.deQueue();
		q.displayQueue();
		
		q.enQueue(8);
		q.displayQueue();
		
		System.out.println("Empty ?: " + q.isEmpty());
		System.out.println("Size of Queue is: " + q.getSize());
		System.out.println("Front Ele is: " + q.getFront());
		System.out.println("Rear Ele is: " + q.getRear());
		
		q.deQueue();
		q.displayQueue();
		
		System.out.println("Rear Ele is: " + q.getRear());
		q.displayQueue();
		
	}
}
